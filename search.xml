<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker 操作整理</title>
      <link href="/2025/11/05/docker-%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/"/>
      <url>/2025/11/05/docker-%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-docker-基本命令"><a href="#1-docker-基本命令" class="headerlink" title="1 docker 基本命令"></a>1 docker 基本命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p -e -v --network container_name</span><br><span class="line">docker ps -a</span><br><span class="line">docker <span class="built_in">rm</span> container_name</span><br><span class="line">docker rmi image_name</span><br><span class="line">docker inpect container_name</span><br><span class="line">docker <span class="built_in">log</span> container_name</span><br><span class="line">docker pull &lt;image_name&gt;</span><br><span class="line">docker images <span class="comment"># 展示所有镜像</span></span><br><span class="line">docker stop container_name</span><br></pre></td></tr></table></figure><ul><li>关于docker run 命令<ul><li>应当把run命令当做运行一个任务或者进程，完成了一个任务就会自动结束（保留下来算是任务执行过程的痕迹）</li><li>直接执行的时候，docker 运行的容器其实没有attach 到当前的命令行窗口中，无法读取 input 并且利用 Terminal 输出 需要加入 it 选项进行交互（否则只会输出一个最终结果?）</li><li>detach 完全进入后台运行</li><li>我希望将docker host 的一个端口映射给容器的某个端口，完成网络访问，可以使用 p 选项， 一定是外 对 内（内就是 container）</li><li>有的时候，不想总是改容器镜像中的脚本（其实是拷贝出来一份）所以把容易变化的当做环境变量，在脚本里面读取，在运行的时候设置，使用 -e</li><li>不希望容器内的数据随着容器的销毁而消失，所以会想要把数据卷挂载到容器某个路径下，这样容器写这个路径，就相当于向着外部数据卷进行写入，使用 -v   volume（不过这是老式的写法)</li><li>新版的挂载数据卷的方式：docker run –mount type&#x3D;bind,source&#x3D;&#x2F;data&#x2F;mysql,target&#x3D;&#x2F;var&#x2F;ilb&#x2F;mysql container_name</li><li>指定所在的网络就用 –network 具体在网络部分展开</li></ul></li><li>想要查看所有正在运行或者停止运行的所有容器：使用 -a 选项 ，docker ps</li><li>删除容器用 rm 表示remove, 删除镜像使用 rmi 表示 remove image</li><li>已经停止运行的容器可以 探测其中的配置和相关改动，用 inspect ?</li><li>正在运行的容器使用 log 探查日志输出</li><li>想要拉取镜像？使用 pull 就好（当然像私有库推送镜像使用 push）但是记者这个每次只能写入一个镜像名，否则会报错</li><li>想要停止容器运行就使用 stop 吧</li></ul><h2 id="2-docker-制作镜像"><a href="#2-docker-制作镜像" class="headerlink" title="2 docker 制作镜像"></a>2 docker 制作镜像</h2><h5 id="Dockerfile-基本命令"><a href="#Dockerfile-基本命令" class="headerlink" title="Dockerfile 基本命令"></a>Dockerfile 基本命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN</span><br><span class="line">CMD</span><br><span class="line">ENTRYPOINT</span><br><span class="line">COPY</span><br><span class="line">WORKDIR</span><br><span class="line">FROM</span><br></pre></td></tr></table></figure><ul><li>ENTRYPOINT 和 CMD 是配合使用的<ul><li>如果 没有 ENTRYPOINT 并且没有命令行指定命令，那么默认CMD是启动时要执行的命令<ul><li>此时可采用JSON 格式或者直接写空格分隔的命令两种形式</li></ul></li><li>如果命令行里有指定命令，那么使用命令行中的命令</li><li>如果ENTRYPOINT 有指定（就是确定了要执行哪个程序）<ul><li>CMD只能使用 JSON 格式，表示默认的这个程序执行时的参数</li><li>命令行可以覆盖CMD中的默认参数</li><li>如果命令行参数不够，默认会使用 JSON 格式指明的 CMD 中的参数append ?</li></ul></li></ul></li><li>FROM 基础镜像</li><li>RUN 执行一系列命令来构成镜像新的一层</li><li>COPY 拷贝外部文件到镜像的一层内</li><li>WORKDIR 指定容器运行的工作目录 ?</li></ul><h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build Dockerfile -t image_name </span><br></pre></td></tr></table></figure><h2 id="3-docker-compose-使用"><a href="#3-docker-compose-使用" class="headerlink" title="3 docker-compose 使用"></a>3 docker-compose 使用</h2><ul><li>把需要成组运行的服务写到一个yaml 文件。</li><li>直接使用 docker-compose up 运行</li><li>文件结构</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line"><span class="attr">port:</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line"><span class="attr">port:</span></span><br></pre></td></tr></table></figure><ul><li>分了不同的版本，目前最新版本是版本3</li><li>可以指定网络，直接用服务名可以解析出 IP 地址（默认是绑定到网络 docker0)</li><li>可以指定数据卷、端口等</li></ul><h2 id="4-docker-底层原理"><a href="#4-docker-底层原理" class="headerlink" title="4 docker 底层原理"></a>4 docker 底层原理</h2><ul><li>使用分层文件系统 路径在 &#x2F;var&#x2F;lib&#x2F;docker<ul><li>aufs（表示的是这个文件系， 常见系统还有 ZFS, BTRFS等）</li><li>container</li><li>image</li><li>volumes 默认的数据卷都在这个路径下</li><li>相关的文件都存储在对应的文件夹下面</li></ul></li><li>镜像<ul><li>都是分层的文件，利用Dockerfile 文件各个命令作为一层进行制作</li><li>制作完成之后内容只读</li></ul></li><li>容器<ul><li>在镜像的基础上，加上一层可读可写层，如果要修改镜像中的内容，会拷贝一份进行修改 （由分层文件系统完成）</li><li>但是这一层只在容器存在的时候存在</li></ul></li><li>docker 运行结构<ul><li>分为三层<ul><li>Docker CLI 与用户命令交互的命令行终端</li><li>REST API Server 程序与守护进程交互的一系列接口</li><li>Docker Daemon 后台守护者进程，管理所有镜像、容器等对象</li></ul></li><li>在各个部分区分了命令空间，使得各个容器运行互相不干扰<ul><li>进程ID</li><li>Network </li><li>InterProcess communication</li><li>Mount</li><li>Unix Time Sharing</li></ul></li></ul></li><li>使用 cgroups 可以进行资源控制 【control groups】</li></ul><h2 id="5-docker-网络"><a href="#5-docker-网络" class="headerlink" title="5 docker 网络"></a>5 docker 网络</h2><blockquote><p>补充知识：<br>    私有 IP 如： 192.168.x.x、 10.x.x.x、 172.16.x.x ~ 172.31.x.x 不可被互联网直接访问<br>    默认网关指的是：当前网络中，负责转发不在本地子网内的数据包的下一跳 IP 地址,它不一定能访问公网，但必须能连接到“外面”；<br>    基本上发送到默认网关 MAC 地址的数据包，都是“要发到外部网络”的<br>    关于网桥（只能看到MAC，看不到 IP ）：<br>        会学习每个 MAC 是从哪个接口来的（MAC 学习表）；<br>        如果它知道目标 MAC → 只发到对应接口；<br>        如果它不知道目标 MAC → 广播到所有接口（Flood）。</p></blockquote><ul><li>如果是网桥模式：<ul><li>每个容器将分配一个子网 IP ，如 172.17.0.2&#x2F;16 ，如果它想要发送请求到 公网 ip  8.8.8.8 ,首先，它得找到本子网段的网关对应的mac 地址，以便于它知道自己的下一跳是哪里。于是它广播了一个 ARP 请求，询问网关的MAC</li><li>内核网关 docker0 以 172.16.0.1 的身份接收到请求后，发送了自己的MAC地址，于是该容器记录了这个MAC地址，发送了目的IP 是  8.8.8.8 的请求。</li><li>网关 docker0 接收到请求后，将请求发送到网络 “外部”，这个请求将注入宿主机协议栈，宿主机物理网卡就是中间的一跳，如果发现目标 ip 不在当前子网中，就会发送给当前网段的默认网关，即路由器，路由器将请求发送出去。</li></ul></li><li>使用 host 模式后：<ul><li>容器就像是“宿主机的一个进程”一样参与网络；</li><li>它直接在宿主机所在局域网中；</li><li>也直接使用宿主机的默认网关；</li><li>但也失去了容器间网络隔离的优势。</li></ul></li><li>container 模式：<ul><li>两台容器公用统一IP 和端口</li></ul></li><li>none 模式：<ul><li>只允许容器自己给自己发消息</li></ul></li><li>自定义网络模式：<ul><li>相比于直接的桥接模式，自定义网络本身就建立了主机名和ip 的映射关系，不管是ping 主机名还是 ping  IP 都能 ping 通</li></ul></li><li>docker0 网络内部存在DNS服务器 172.12.0.11 ， 可以把容器名解析到对应的局域网IP</li></ul><h5 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 182.18.0.0/16  custom_network_name</span><br></pre></td></tr></table></figure><ul><li>如果直接inspect 能发现网关、IPAddress、MacAddress 等网络字段</li></ul><h2 id="6-Docker-集群"><a href="#6-Docker-集群" class="headerlink" title="6 Docker 集群"></a>6 Docker 集群</h2><ul><li>可以使用 Docker Swarm</li><li>但是使用 Kubernets 更方便</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 基本操作</title>
      <link href="/2025/11/05/git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/11/05/git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p> git 本质<br>    存在一个 对象池 object<br>    stage, branch0, branch1, … 都是一些指针目录树，树上的每个结点会指向对象池里的一个对象【一个分支就是一个目录树，树上结点就是指向某个对象的指针】<br>    HEAD 指向的是本地分支库中当前工作的分支（就是记录当前目录树的 git_pos)<br>    origin 中就是远程分支库在本地的副本 origin&#x2F;main 就是一个副本目录树</p></blockquote><ul><li><a href="https://learngitbranching.js.org/?locale=zh_CN">学习网站</a></li></ul><h2 id="1-Git-基本命令"><a href="#1-Git-基本命令" class="headerlink" title="1 Git 基本命令"></a>1 Git 基本命令</h2><h5 id="基本配置命令"><a href="#基本配置命令" class="headerlink" title="基本配置命令"></a>基本配置命令</h5><figure class="highlight plaintext"><figcaption><span>config --global user.name # 配置文件在 ~/.gitconfig 下面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email</span><br><span class="line">git init</span><br><span class="line">git add </span><br><span class="line">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="状态查看指令"><a href="#状态查看指令" class="headerlink" title="状态查看指令"></a>状态查看指令</h5><ul><li><code>git status </code><ul><li>查看当前所处的分支、各个文件的状态（在工作区、暂存区…) 和基本信息</li></ul></li><li><code>git reflog</code>    查看之前的版本<ul><li><code>git reflog -n 数量</code> 可以指定查看数目的版本</li></ul></li><li><code>git log</code> 可以查看详细的版本信息，但是建议使用 <code>git log --reverse --oneline </code></li></ul><h5 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h5><ul><li>一般而言使用 哈希值的前四位可以识别一个提交<ul><li>但是这样不方便，每次都要git reflog 来查找</li></ul></li><li>使用相对引用操作符<ul><li>~ ^ 在某个位置标记后面</li><li>~3 表示回退三次</li><li>^2 表示选择多parent 的非直线parent</li><li>单次使用 ^ 表示回退一次</li></ul></li><li><code>git tag tag_name git_pos</code> 勤劳打tag，固定某个位置作为某个版本<ul><li><code>git describe</code> 可以根据 最近的tag 返回描述</li></ul></li></ul><h2 id="2-单线操作指令"><a href="#2-单线操作指令" class="headerlink" title="2 单线操作指令"></a>2 单线操作指令</h2><h5 id="文件恢复"><a href="#文件恢复" class="headerlink" title="文件恢复"></a>文件恢复</h5><ul><li><code>git restore file</code>  从暂存区获取并回滚文件</li><li>用暂存目录树切换掉当前工作区， <code>git checkout . </code></li><li><code>git reset</code> 版本号   这里的版本号可以用 git reflog  查看<ul><li>hard 是 HEAD指向，工作区和暂存区都重置</li><li>mixed 是仅仅 HEAD指向和暂存区重置</li><li>soft 是仅仅 HEAD 指向重置</li></ul></li></ul><h5 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h5><ul><li><code>git reset git_pos</code> 把HEAD重置到某个版本</li><li><code>git revert branch_name</code>不一样<ul><li>会创建一个新的提交，而这次提交的内容其实只是为了说明回撤到了某个版本</li><li>说明转回某个版本了，但是中间的历史没有覆盖</li><li>目的在于把代码库的撤销更改能够应用到远程库，使大家能共享（如果不这样的话，历史会不一致，导致无法提交）</li></ul></li></ul><h2 id="3-分支操作"><a href="#3-分支操作" class="headerlink" title="3 分支操作"></a>3 分支操作</h2><h5 id="创建、删除展示分支"><a href="#创建、删除展示分支" class="headerlink" title="创建、删除展示分支"></a>创建、删除展示分支</h5><ul><li><code>git checkout -b new-feature</code>  创建一个 叫做 new-feature 的新分支（并且立马切换过去）</li><li><code>git branch -d</code> 名字  可以删除指定名字的分支</li><li>git branch   展示分支</li></ul><h5 id="跳转与分支操作"><a href="#跳转与分支操作" class="headerlink" title="跳转与分支操作"></a>跳转与分支操作</h5><ul><li>切换分支使用 git checkout 分支名 </li><li>用git_pos指定的提交版本切换掉工作区和暂存区 <code>git checkout git_pos . </code> <ul><li>如果是单个文件使用 <code>git checkout git_pos -- &lt;filename&gt;</code></li></ul></li><li>分离 HEAD<ul><li><code>git checkout git_pos</code> 使得 HEAD 指向回退到这个版本的代码</li></ul></li><li><code>git branch -f main git_pos</code>  把main 分支移动到hash_pos 指定的位置，main 分支从这里开始重新提交</li><li><code>git branch -m master main  move/rename</code> 重命名</li></ul><h5 id="分支整理"><a href="#分支整理" class="headerlink" title="分支整理"></a>分支整理</h5><ul><li><code>git merge</code> 其他分支  把其他分支的内容合并到当前分支</li><li><code>git rebase a b</code>  利用 b 操作 a 分支（把 b 上提交变基到a上，在a上创建一系列提交)<ul><li>会有一个清晰的提交线，提交历史不会打结</li></ul></li><li><code>git cherry-pick git_pos1 git_pos2 …</code> 挑选 patch 在当前分支下<ul><li>尤其适用于某个测试分支下，先前写了很多版本的printf 的代码，只需要最后一个版本的改动，直接只pick 最后一个版本的改动</li></ul></li><li><code>git rebase -i main </code> 在main分支所在位置列出接下来可能的版本，手动拖拽 patch 调整位置，选择是否omit，或者</li></ul><h2 id="4-Git-远程操作"><a href="#4-Git-远程操作" class="headerlink" title="4 Git 远程操作"></a>4 Git 远程操作</h2><h5 id="远程仓库和本地库"><a href="#远程仓库和本地库" class="headerlink" title="远程仓库和本地库"></a>远程仓库和本地库</h5><p><code>git push -u origin main</code>推送<br><code>git fetch origin</code>拉取远程仓库内容到本地</p><h5 id="远程仓库和工作区"><a href="#远程仓库和工作区" class="headerlink" title="远程仓库和工作区"></a>远程仓库和工作区</h5><p><code>git pull origin main = git fetch origin + git  merge origin/main</code> </p><h5 id="设置和修改远程库"><a href="#设置和修改远程库" class="headerlink" title="设置和修改远程库"></a>设置和修改远程库</h5><p><code>git remote add origin </code>地址  添加远程库<br><code>git remote set-url origin </code>地址  修改远程库<br><code>git remote rm origin </code> 删除远程库<br><code>git remote -v </code> 查看远程库信息</p><h5 id="具体远程操作"><a href="#具体远程操作" class="headerlink" title="具体远程操作"></a>具体远程操作</h5><ul><li>如果直接操作 origin&#x2F;main 会直接变成分离头模式<ul><li>应为origin&#x2F;main 其实是和远程最近一次拉取保持同步的，强行操作会导致版本历史无法对应</li></ul></li><li>拉取、整合代码<ul><li><code>git fetch</code>  把所有远程分支的代码拉取下来<ul><li><code>git fetch origin main</code> 只把main 分支的代码拉取下来</li><li>参数可以使用 <code>&lt;source&gt;:&lt;destination&gt;</code> 指定，其中 source 可以是在远程的 git_pos (把具体某个版本的代码拉取到固定的分支</li><li>如果 <code>git fetch origin :bar</code> 会在本地新建 bar 分支</li></ul></li><li>git pull  把默认追踪的分支代码拉取下来并merge<ul><li>把更改合并到当前分支 ≈ <code>git fetch + git merge</code>（一定是合并的HEAD指向的分支，而不是main 分支）</li><li><code>git pull -- rebase</code>  采用变基的方式更新主枝代码（把origin&#x2F;main 的代码变基到主枝</li></ul></li></ul></li><li>推送代码<ul><li>git push  完成默认跟踪分支的代码的推送<ul><li>加入参数 <code>git push origin &lt;source&gt;:&lt;destination&gt;</code> 其中 source 可以是任何git 能识别的版本标识，可以把本地任何一个版本的代码推动过去，destination 表示远程的某个分支</li><li>推送的时候需要保证 和远程分支的历史是一致的，如果不一致需要先  git pull  或者 git pull – rebase 进行拉取整合之后再push</li><li>如果使用 <code>git push origin :foo</code> 会删除远程的foo分支</li><li><code>git push -u</code>  选项表示 set-upstream 就是设置分支跟踪的远程分支</li></ul></li></ul></li><li>变更追踪远程分支的分支<ul><li><code>git checkout -b foo o/main </code>新建一个分支foo 默认让foo 跟踪远程的 main 分支</li><li><code>git branch -u o/main foo</code>  如果 foo 已经在使用了可以用branch命令，并追踪远程分支 origin&#x2F;main</li></ul></li></ul><h2 id="5-使用建议"><a href="#5-使用建议" class="headerlink" title="5 使用建议"></a>5 使用建议</h2><ul><li>切换版本<code> git checkout</code></li><li>创建分支 <code>git checkout -b name</code> 如果你有很多个想法，直接开多个分支实现就好了，然后在 readme 文件中写好自己的想法的实现步骤，这样就不用建立很多个不同名字的库了，真的很难管理！而且如果data 这样的目录没有被管理到，就是所有分支共享的，这样数据使用也很方便</li><li>回溯版本<ul><li>不保留工作区的内容并且不覆盖之前的历史，只是做替换：<code>git checkout git_pos .</code></li><li>不保留工作区的内容，逻辑上将要覆盖掉reset到的版本之后的提交的历史(但是在 reflog 中仍然可以找到） 从reset的版本之后继续给出新的提交 <code>git reset --hard git_pos</code></li><li>保留工作区内容，但是暂存区改写，并且从 reset版本开始重新提交 <code>git reset --mixed git_pos</code></li><li>保留工作区和暂存区的内容，仅仅从 reset 到的版本重新开始提交 <code>git reset -soft git_pos</code></li></ul></li><li><code>git fetch origin</code>, 先比对，之后 <code>git merge origin/main</code> 合并，在很有信心需要直接合并的时候再使用 <code>git pull origin main</code></li><li>直接使用可视化工具查看 git 分支和提交信息</li><li>添加远程库 <code>git remote add origin</code> 地址</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/10/29/hello-world/"/>
      <url>/2025/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客初始化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim 基本操作</title>
      <link href="/2025/10/13/vim-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/10/13/vim-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="vim-命令参考表"><a href="#vim-命令参考表" class="headerlink" title="vim 命令参考表"></a>vim 命令参考表</h1><h2 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1. 光标移动"></a>1. 光标移动</h2><h3 id="1-1-基本移动"><a href="#1-1-基本移动" class="headerlink" title="1.1 基本移动"></a>1.1 基本移动</h3><ul><li><code>h</code> → 向左移动  </li><li><code>j</code> → 向下移动  </li><li><code>k</code> → 向上移动  </li><li><code>l</code> → 向右移动  </li><li><code>0</code> → 移动到行首  </li><li><code>$</code> → 移动到行尾  </li><li><code>^</code> → 移动到行首非空字符</li></ul><h3 id="1-2-单词与句子移动"><a href="#1-2-单词与句子移动" class="headerlink" title="1.2 单词与句子移动"></a>1.2 单词与句子移动</h3><ul><li><code>w</code> → 跳到下一个单词开头  </li><li><code>e</code> → 跳到下一个单词结尾  </li><li><code>b</code> → 跳到上一个单词开头  </li><li><code>)</code> → 下一句  </li><li><code>(</code> → 上一句</li></ul><h3 id="1-3-段落与配对符号"><a href="#1-3-段落与配对符号" class="headerlink" title="1.3 段落与配对符号"></a>1.3 段落与配对符号</h3><ul><li><code>&#123;</code> → 上一段  </li><li><code>&#125;</code> → 下一段  </li><li><code>%</code> → 跳转到匹配的括号、花括号或方括号</li></ul><h3 id="1-4-行与文件导航"><a href="#1-4-行与文件导航" class="headerlink" title="1.4 行与文件导航"></a>1.4 行与文件导航</h3><ul><li><code>gg</code> → 跳到文件第一行  </li><li><code>G</code> → 跳到文件最后一行  </li><li><code>:n</code> → 跳到第 <em>n</em> 行  </li><li><code>H</code>, <code>M</code>, <code>L</code> → 屏幕顶部 &#x2F; 中间 &#x2F; 底部</li></ul><hr><h2 id="2-编辑命令"><a href="#2-编辑命令" class="headerlink" title="2. 编辑命令"></a>2. 编辑命令</h2><h3 id="2-1-插入与删除"><a href="#2-1-插入与删除" class="headerlink" title="2.1 插入与删除"></a>2.1 插入与删除</h3><ul><li><code>i</code> → 在光标前插入  </li><li><code>a</code> → 在光标后插入  </li><li><code>o</code> &#x2F; <code>O</code> → 在下方 &#x2F; 上方新开一行  </li><li><code>x</code> → 删除光标处字符  </li><li><code>dd</code> → 删除当前行  </li><li><code>D</code> → 删除至行尾</li></ul><h3 id="2-2-复制、剪切、粘贴"><a href="#2-2-复制、剪切、粘贴" class="headerlink" title="2.2 复制、剪切、粘贴"></a>2.2 复制、剪切、粘贴</h3><ul><li><code>yy</code> → 复制当前行  </li><li><code>y&#123;motion&#125;</code> → 按动作复制（如 <code>yw</code>, <code>y$</code>）  </li><li><code>p</code> → 在光标后粘贴  </li><li><code>P</code> → 在光标前粘贴  </li><li><code>d&#123;motion&#125;</code> → 按动作删除（相当于剪切）</li></ul><h3 id="2-3-替换与修改"><a href="#2-3-替换与修改" class="headerlink" title="2.3 替换与修改"></a>2.3 替换与修改</h3><ul><li><code>r&#123;char&#125;</code> → 替换单个字符  </li><li><code>R</code> → 连续替换直到退出  </li><li><code>cw</code> → 修改一个单词  </li><li><code>cc</code> → 修改整行  </li><li><code>C</code> → 修改至行尾</li></ul><hr><h2 id="3-撤销与重复"><a href="#3-撤销与重复" class="headerlink" title="3. 撤销与重复"></a>3. 撤销与重复</h2><ul><li><code>u</code> → 撤销上一步操作  </li><li><code>Ctrl + r</code> → 重做  </li><li><code>.</code> → 重复上一个编辑命令</li></ul><hr><h2 id="4-搜索与替换"><a href="#4-搜索与替换" class="headerlink" title="4. 搜索与替换"></a>4. 搜索与替换</h2><h3 id="4-1-搜索"><a href="#4-1-搜索" class="headerlink" title="4.1 搜索"></a>4.1 搜索</h3><ul><li><code>/pattern</code> → 向前搜索  </li><li><code>?pattern</code> → 向后搜索  </li><li><code>n</code> &#x2F; <code>N</code> → 重复搜索（同方向 &#x2F; 反方向）</li></ul><h3 id="4-2-替换"><a href="#4-2-替换" class="headerlink" title="4.2 替换"></a>4.2 替换</h3><ul><li><code>:%s/old/new/g</code> → 全文替换  </li><li><code>:s/old/new/</code> → 当前行替换  </li><li>追加 <code>c</code> 标志（如 <code>gc</code>）可逐个确认</li></ul><hr><h2 id="5-寄存器（Registers）"><a href="#5-寄存器（Registers）" class="headerlink" title="5. 寄存器（Registers）"></a>5. 寄存器（Registers）</h2><h3 id="5-1-命名寄存器"><a href="#5-1-命名寄存器" class="headerlink" title="5.1 命名寄存器"></a>5.1 命名寄存器</h3><ul><li><code>&quot;a</code> ~ <code>&quot;z</code> → 共 26 个命名寄存器  <ul><li><code>&quot;ayy</code> → 复制当前行到寄存器 a  </li><li><code>&quot;ap</code> → 从寄存器 a 粘贴</li></ul></li></ul><h3 id="5-2-特殊寄存器"><a href="#5-2-特殊寄存器" class="headerlink" title="5.2 特殊寄存器"></a>5.2 特殊寄存器</h3><ul><li><code>&quot;</code> → 默认寄存器  </li><li><code>&quot;0</code> → 最近一次复制的内容  </li><li><code>&quot;1</code>–<code>&quot;9</code> → 最近九次删除记录  </li><li><code>&quot;%</code> → 当前文件名  </li><li><code>&quot;:</code> → 最近命令  </li><li><code>&quot;/</code> → 最近搜索内容</li></ul><h3 id="5-3-系统剪贴板"><a href="#5-3-系统剪贴板" class="headerlink" title="5.3 系统剪贴板"></a>5.3 系统剪贴板</h3><ul><li><code>&quot;+</code> → 系统剪贴板  <ul><li><code>&quot;+y</code> → 复制到系统剪贴板  </li><li><code>&quot;+p</code> → 从系统剪贴板粘贴</li></ul></li><li><code>&quot;*</code> → 主选择缓冲区（Linux&#x2F;X11）</li></ul><hr><h2 id="6-文本对象（Text-Objects）"><a href="#6-文本对象（Text-Objects）" class="headerlink" title="6. 文本对象（Text Objects）"></a>6. 文本对象（Text Objects）</h2><p>文本对象允许对逻辑块执行命令（如“一个单词”、“一段文字”）。</p><h3 id="6-1-常用文本对象"><a href="#6-1-常用文本对象" class="headerlink" title="6.1 常用文本对象"></a>6.1 常用文本对象</h3><ul><li><code>aw</code> &#x2F; <code>iw</code> → 一个单词 &#x2F; 内部单词  </li><li><code>as</code> &#x2F; <code>is</code> → 一句话 &#x2F; 内部句子  </li><li><code>ap</code> &#x2F; <code>ip</code> → 一段落 &#x2F; 内部段落</li></ul><h3 id="6-2-成对符号对象"><a href="#6-2-成对符号对象" class="headerlink" title="6.2 成对符号对象"></a>6.2 成对符号对象</h3><ul><li><code>a&quot;</code> &#x2F; <code>i&quot;</code> → 含引号 &#x2F; 引号内  </li><li><code>a&#39;</code> &#x2F; <code>i&#39;</code> → 含单引号 &#x2F; 单引号内  </li><li><code>a)</code> &#x2F; <code>i)</code> → 含括号 &#x2F; 括号内  </li><li><code>a]</code> &#x2F; <code>i]</code>, <code>a&#125;</code> &#x2F; <code>i&#125;</code> → 方括号 &#x2F; 花括号内  </li><li><code>at</code> &#x2F; <code>it</code> → 含 HTML 标签 &#x2F; 标签内内容</li></ul><h3 id="6-3-使用示例"><a href="#6-3-使用示例" class="headerlink" title="6.3 使用示例"></a>6.3 使用示例</h3><ul><li><code>daw</code> → 删除一个单词（含空格）  </li><li><code>ci&quot;</code> → 修改引号内文字  </li><li><code>yap</code> → 复制一个段落</li></ul><hr><h2 id="7-标记与跳转"><a href="#7-标记与跳转" class="headerlink" title="7. 标记与跳转"></a>7. 标记与跳转</h2><h3 id="7-1-标记"><a href="#7-1-标记" class="headerlink" title="7.1 标记"></a>7.1 标记</h3><ul><li><code>m&#123;a-z&#125;</code> → 设置标记  </li><li><code>&#39;a</code> → 跳到标记 a 所在行  </li><li><code> `a</code> → 跳到标记 a 精确位置</li></ul><h3 id="7-2-跳转"><a href="#7-2-跳转" class="headerlink" title="7.2 跳转"></a>7.2 跳转</h3><ul><li><code>Ctrl + o</code> → 返回上一个位置  </li><li><code>Ctrl + i</code> → 前进到下一个位置  </li><li><code>&#39;&#39;</code> → 返回上一行  </li><li><code> </code> &#96;&#96; → 返回上一个精确光标位置</li></ul><hr><h2 id="8-窗口与文件操作"><a href="#8-窗口与文件操作" class="headerlink" title="8. 窗口与文件操作"></a>8. 窗口与文件操作</h2><ul><li><code>:e file</code> → 打开文件  </li><li><code>:w</code> &#x2F; <code>:q</code> → 保存 &#x2F; 退出  </li><li><code>:wq</code> &#x2F; <code>ZZ</code> → 保存并退出  </li><li><code>:q!</code> → 不保存退出  </li><li><code>:split</code> &#x2F; <code>:vsplit</code> → 水平 &#x2F; 垂直分割窗口  </li><li><code>Ctrl + w + w</code> → 切换窗口  </li><li><code>:tabnew</code> &#x2F; <code>gt</code> &#x2F; <code>gT</code> → 新标签 &#x2F; 下一个 &#x2F; 上一个</li></ul><hr><h2 id="9-可视与行操作"><a href="#9-可视与行操作" class="headerlink" title="9. 可视与行操作"></a>9. 可视与行操作</h2><ul><li><code>V</code> → 选中整行  </li><li><code>Ctrl + v</code> → 选中矩形块（可视块）  </li><li>对选中内容可使用 <code>y</code>, <code>d</code>, <code>&gt;</code>, <code>&lt;</code> 等操作  </li><li><code>=</code> → 自动缩进选区</li></ul><hr><h2 id="10-其他常用命令"><a href="#10-其他常用命令" class="headerlink" title="10. 其他常用命令"></a>10. 其他常用命令</h2><ul><li><code>:set number</code> → 显示行号  </li><li><code>:set relativenumber</code> → 显示相对行号  </li><li><code>:set paste</code> &#x2F; <code>:set nopaste</code> → 开 &#x2F; 关粘贴模式  </li><li><code>:help &#123;命令&#125;</code> → 查看帮助</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux 系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT 作图整理</title>
      <link href="/2025/09/30/PPT-%E4%BD%9C%E5%9B%BE%E6%95%B4%E7%90%86/"/>
      <url>/2025/09/30/PPT-%E4%BD%9C%E5%9B%BE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>资源链接</p><blockquote><p><a href="https://www.bilibili.com/video/BV1HZ4y1b7MJ?spm_id_from=333.788.player.switch&vd_source=b19e0d9a8fc02f14e7f3cbadf24cc4ca&p=5">课程链接</a></p></blockquote></blockquote><h2 id="1-绘图案例总结"><a href="#1-绘图案例总结" class="headerlink" title="1 绘图案例总结"></a>1 绘图案例总结</h2><ul><li>不规则曲线绘制<ul><li>delete 删点</li><li>在角度比较尖锐的时候，可以按下ctrl键画直线</li><li>在轮廓线上右击选择编辑顶点可以编辑顶点</li><li>曲线结尾是可以带箭头的</li></ul></li><li>图形是可以镜像变换的</li><li>绘制好的图在粘贴的时候选择以图片格式粘贴，改大小的时候文字就不会发生位移</li></ul><h2 id="2-基本绘图知识"><a href="#2-基本绘图知识" class="headerlink" title="2 基本绘图知识"></a>2 基本绘图知识</h2><ul><li>图片分为位图和矢量图<ul><li>矢量图形(graphic)：根据几何特性绘制，用线段和曲线描述图像，只能靠软件生成</li><li>位图(图像image)：像素点构成</li></ul></li><li>分辨率<ul><li>图片分辨率：作图的长宽像素乘积</li><li>设备分辨率：显示屏的分辨率，1080<em>720，1920</em>1080，4 K, 8 K</li><li>打印分辨率：300dpi, 600 dpi</li></ul></li><li>控制输出的分辨率：<ul><li>PowerPoint 2016: HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\PowerPoint\Options</li><li>新建Dword 字段，ExportionBitmapResolution &#x3D; 结果</li></ul></li></ul><h2 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3 快捷键"></a>3 快捷键</h2><ul><li>按住ctrl 键用鼠标左键可对对象进行中心放大或缩小</li><li>shift 键<ul><li>等比例缩放（可以绘制正圆）</li><li>只能水平或垂直移动</li><li>每次旋转为 15 度</li></ul></li><li>ctrl +shift 键 <ul><li>拖动对象将进行水平或者竖直复制对象</li><li>等比例中心放大或者缩小</li></ul></li><li>组合快捷键<ul><li>ctrl + D 位置关系进行复制粘贴！（第二个相对于第一个的位置关系也会复制下来）</li><li>alt + F10 对象选择窗格（调整图层）</li><li>ctrl + 上下左右方向键：相比于直接按下上下左右方向键更加精细的微调</li><li>shift + 上下左右方向键：对对象进行纵向或者横向的缩放</li><li>alt + 左右方向键：进行 15 度旋转</li></ul></li><li>自定义快速访问工具栏<ul><li>形状插入（常用的形状）</li><li>文本处理（字体，大小…)</li><li>形状对齐</li><li>形状合并（粘合，组合，拆分，剪切…)</li><li>上下移动一层</li></ul></li></ul><h2 id="4-科研作图要素"><a href="#4-科研作图要素" class="headerlink" title="4 科研作图要素"></a>4 科研作图要素</h2><h5 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h5><ul><li>角度校准<ul><li>鼠标右键→ 设置网格和参考线（移动需要在作图区域以外）<ul><li>按住ctrl键，进行拖动可以生成一条新的参考线</li></ul></li><li>在设置图片格式里面可以微调角度</li></ul></li><li>剪裁<ul><li>用自己绘制的形状剪裁更好用</li><li>如果图片经过了旋转，无法进行合理对齐，可以先剪切，然后选择图片格式粘贴（粘贴完之后就是正常无旋转的图片了）</li></ul></li><li>调整大小</li><li>调色<ul><li>可以在图片→ 校正里面调整亮度和对比度</li></ul></li></ul><h5 id="图片排版组合"><a href="#图片排版组合" class="headerlink" title="图片排版组合"></a>图片排版组合</h5><ul><li>第一步设置幻灯片大小<ul><li>设计→ 大小→ 自定义幻灯片大小<ul><li>双栏图片一般是 17.2cm</li></ul></li></ul></li><li>图片排版<ul><li>简单缩放</li><li>不行就剪裁</li></ul></li></ul><h5 id="画中画效果"><a href="#画中画效果" class="headerlink" title="画中画效果"></a>画中画效果</h5><ul><li>建矩形框<ul><li>调节和图片大小一致</li></ul></li><li>把图片剪切</li><li>设置矩形框格式<ul><li>选择用图片填充<br>   图片来自剪切板</li></ul></li><li>之后可以调节透明度（如果直接就是图片，无法直接调节透明度）</li><li>然后对齐</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex 引擎</title>
      <link href="/2025/08/05/latex-%E5%BC%95%E6%93%8E/"/>
      <url>/2025/08/05/latex-%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="1-latex-引擎的选用"><a href="#1-latex-引擎的选用" class="headerlink" title="1 latex 引擎的选用"></a>1 latex 引擎的选用</h2><h3 id="1-1-pdfLaTeX"><a href="#1-1-pdfLaTeX" class="headerlink" title="1.1 pdfLaTeX"></a>1.1 pdfLaTeX</h3><ul><li><strong>最传统、最稳定</strong> 的引擎（默认 <code>latexmk -pdf</code> 就是用它）。</li><li>直接输出 PDF（比传统的 DVI → PS → PDF 流程快很多）。</li><li><strong>优点：</strong><ul><li>速度快、兼容性好，大部分宏包都优先支持。</li><li>生成的 PDF 体积小，质量高。</li><li>数学排版最成熟。</li></ul></li><li><strong>缺点：</strong><ul><li>只支持 <strong>8-bit 编码</strong>（比如 Latin-1），对中文等非西方文字支持差。</li><li>字体必须用 <code>.tfm/.pfb</code> 这种老式格式，无法直接用系统字体（宋体、Times New Roman 等要额外配置）。</li></ul></li><li><strong>适用场景：</strong><ul><li>纯英文论文&#x2F;书籍。</li><li>没有复杂字体需求，或者使用已有的宏包（如 <code>CJK</code> 宏包）处理中文。</li></ul></li></ul><h3 id="1-2-XeLaTeX"><a href="#1-2-XeLaTeX" class="headerlink" title="1.2 XeLaTeX"></a>1.2 XeLaTeX</h3><ul><li>基于 <strong>XeTeX</strong>，现代化的引擎，支持 Unicode。</li><li><strong>优点：</strong><ul><li>天然支持 <strong>UTF-8 编码</strong> → 中文直接写就能用（配合 <code>ctex</code> 宏包特别方便）。</li><li>能调用系统字体（用 <code>fontspec</code> 就能用 Windows&#x2F;Mac&#x2F;Linux 上的字体）。</li><li>数学公式也可以用 Unicode 方式书写。</li></ul></li><li><strong>缺点：</strong><ul><li>有些宏包兼容性稍差（因为最早宏包都是为 pdfLaTeX 写的）。</li><li>编译速度比 pdfLaTeX 慢。</li></ul></li><li><strong>适用场景：</strong><ul><li>中文文档（<code>ctex</code> 推荐 XeLaTeX）。</li><li>需要使用自定义字体的文档（比如公司文档要求特定字体）。</li></ul></li></ul><h3 id="1-3-LuaLaTeX"><a href="#1-3-LuaLaTeX" class="headerlink" title="1.3 LuaLaTeX"></a>1.3 LuaLaTeX</h3><ul><li>基于 <strong>LuaTeX</strong>，和 XeLaTeX 类似，也是支持 Unicode 和系统字体。</li><li>内置 Lua 脚本引擎 → 可以在排版过程中做编程扩展。</li><li><strong>优点：</strong><ul><li>支持 UTF-8 和系统字体（同 XeLaTeX）。</li><li>更强大的扩展能力（比如 <code>luacode</code> 宏包能直接写 Lua 脚本）。</li><li>未来的发展方向（LaTeX3 团队倾向推荐 LuaLaTeX）。</li></ul></li><li><strong>缺点：</strong><ul><li>和 XeLaTeX 一样，部分宏包兼容性不如 pdfLaTeX。</li><li>编译速度相对慢。</li></ul></li><li><strong>适用场景：</strong><ul><li>中文&#x2F;多语言文档。</li><li>需要 Lua 脚本扩展功能的高级排版（比如智能断行、复杂表格生成）。</li><li>想跟随 LaTeX 的未来主流趋势。</li></ul></li></ul><h3 id="1-4-总结对比"><a href="#1-4-总结对比" class="headerlink" title="1.4 总结对比"></a>1.4 总结对比</h3><table><thead><tr><th>引擎</th><th>字体支持</th><th>Unicode&#x2F;UTF-8</th><th>中文支持</th><th>宏包兼容性</th><th>速度</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>pdfLaTeX</strong></td><td>传统 Type1&#x2F;TFM</td><td>❌</td><td>很差（需 CJK 宏包）</td><td>最好</td><td>🚀 快</td><td>纯英文文档、经典论文</td></tr><tr><td><strong>XeLaTeX</strong></td><td>系统字体 (<code>fontspec</code>)</td><td>✅</td><td>✅ （推荐配合 ctex）</td><td>一般</td><td>🐢 稍慢</td><td>中文文档、需要特殊字体</td></tr><tr><td><strong>LuaLaTeX</strong></td><td>系统字体 (<code>fontspec</code>)</td><td>✅</td><td>✅ （推荐配合 ctex）</td><td>一般</td><td>🐢 稍慢</td><td>需要脚本扩展、高级功能</td></tr></tbody></table><h3 id="1-5-实际选择指南"><a href="#1-5-实际选择指南" class="headerlink" title="1.5 实际选择指南"></a>1.5 实际选择指南</h3><ul><li><strong>英文论文 &#x2F; 国外期刊模板</strong> → 用 <strong>pdfLaTeX</strong>（最兼容）。</li><li><strong>中文论文 &#x2F; 报告</strong> → 用 <strong>XeLaTeX</strong>（配合 <code>ctex</code> 宏包最稳）。</li><li><strong>中文 + 特殊需求（脚本扩展 &#x2F; 新功能）</strong> → 用 <strong>LuaLaTeX</strong>。</li><li>如果模板（例如 ACM、IEEE）明确要求 <code>pdflatex</code>，那就老老实实用 pdfLaTeX。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大四体测</title>
      <link href="/2024/11/18/%E5%A4%A7%E5%9B%9B%E4%BD%93%E4%BE%A7/"/>
      <url>/2024/11/18/%E5%A4%A7%E5%9B%9B%E4%BD%93%E4%BE%A7/</url>
      
        <content type="html"><![CDATA[<p>大四这会，可能受不了在中南周围的衰颓，也许感觉和自己同行的人越来越少，也许相出去闯荡吧，不愿停滞，乐意去闯，把体侧从11月30日提前到了11月17日，从11月11日开始准备，每天基本会利用1个半小时训练，真的非常希望能够超越过去啊！</p><p>压力还是非常大的，之前长跑已经从 3 min 30 sec -&gt; 3min 27 sec -&gt; 3min 24min -&gt; 3min 23 sec -&gt; 3min 18 sec 了，从大一到大三6次体侧，总是保持一个逐步上升的趋势，我也和自己约定每次一定要比上一次成绩更好，好像这次，我真的做到了，跑出了 3 min 12 sec ！</p><h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><ul><li><p>全面超越：长跑3min21sec，短跑7.2sec，座位体前屈18.4，引体向上14个</p></li><li><p>最后跳远还是 到 255cm，肺活量还是3229</p></li></ul><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><ul><li><p>有提前尽力训练，长跑也全力以赴了，不后悔</p></li><li><p>唯一的缺憾是，技巧上准备不足，没有应对长跑最后一段、短跑、坐位体前屈、肺活量出现的状况</p></li><li><p>而且，其实如果部分测试放到下午可能更好</p><ul><li>当时放下的原因是，时间的消耗可能不会换来一个结果，而且预期是 11 点结束，希望早点结束，而且主要长跑其实超出预期了。</li></ul></li></ul><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><ul><li>尽力无悔！超越了过去，体侧的绝大部分项目都在逐步上涨，比如引体向上，从一个都做不了，到能做1个，再到能做6个，能做 8 个… 感觉尽力在进步！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 向未来交付 </category>
          
          <category> 生活小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础命令合集</title>
      <link href="/2024/11/15/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2024/11/15/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="命令并行"><a href="#命令并行" class="headerlink" title="命令并行"></a>命令并行</h2><table><thead><tr><th>需求</th><th>解决方式</th><th>复杂示例</th></tr></thead><tbody><tr><td>固定数量参数传递</td><td><code>xargs -n 2 command</code></td><td><code>printf &quot;a b\nc d\n&quot; | xargs -n 2 echo</code> → 执行 <code>echo a b</code>、<code>echo c d</code></td></tr><tr><td>自定义参数位置替换</td><td><code>xargs -I &#123;&#125;</code></td><td><code>cat list.txt | xargs -I &#123;&#125; cp &#123;&#125; /backup/&#123;&#125;</code> → 每行替换 <code>&#123;&#125;</code> 为文件名</td></tr><tr><td>多列参数传递</td><td><code>xargs -n 2 sh -c &#39;cmd &quot;$1&quot; &quot;$2&quot;&#39; _</code></td><td><code>cat pairs.txt | xargs -n 2 sh -c &#39;cp &quot;$1&quot; &quot;$2&quot;&#39; _</code> → 每行两个字段作为源和目标</td></tr><tr><td>调试查看命令执行</td><td><code>xargs -t</code></td><td><code>cat files.txt | xargs -t rm</code> → 执行前打印实际命令，如 <code>rm file1</code></td></tr><tr><td>并行执行任务</td><td><code>xargs -P 4</code></td><td><code>cat pairs.txt | xargs -n 2 -P 4 sh -c &#39;cp &quot;$1&quot; &quot;$2&quot;&#39; _</code> → 并行执行 4 个复制任务</td></tr></tbody></table><h2 id="一、用户管理"><a href="#一、用户管理" class="headerlink" title="一、用户管理"></a>一、用户管理</h2><h3 id="1-用户与组管理"><a href="#1-用户与组管理" class="headerlink" title="1. 用户与组管理"></a>1. 用户与组管理</h3><ul><li><code>useradd &lt;用户名&gt;</code>：添加新用户  </li><li><code>passwd &lt;用户名&gt;</code>：设置或修改用户密码  </li><li><code>userdel &lt;用户名&gt;</code>：删除用户  </li><li><code>usermod &lt;选项&gt; &lt;用户名&gt;</code>：修改用户信息（如组、家目录、登录 shell）  </li><li><code>groupadd &lt;组名&gt;</code>：创建新用户组  </li><li><code>groupdel &lt;组名&gt;</code>：删除用户组  </li><li><code>groups &lt;用户名&gt;</code>：查看用户所属组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG <span class="built_in">sudo</span> alice      <span class="comment"># 将用户 alice 添加到 sudo 组</span></span><br><span class="line">usermod -d /home/newhome alice  <span class="comment"># 修改 alice 的家目录</span></span><br><span class="line">usermod -s /bin/bash alice  <span class="comment"># 修改登录 shell 为 bash</span></span><br><span class="line"></span><br><span class="line">groupadd developers    <span class="comment"># 创建一个名为 developers 的用户组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 script.sh       <span class="comment"># 文件拥有者可读写执行，其他人可读执行</span></span><br><span class="line"><span class="built_in">chmod</span> u+x program.sh      <span class="comment"># 给用户增加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> alice:developers /var/www/index.html   <span class="comment"># 修改文件所有者为 alice，所属组为 developers</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chgrp</span> developers project.log    <span class="comment"># 修改文件所属组为 developers</span></span><br></pre></td></tr></table></figure><h3 id="2-用户身份与权限"><a href="#2-用户身份与权限" class="headerlink" title="2. 用户身份与权限"></a>2. 用户身份与权限</h3><ul><li><code>id &lt;用户名&gt;</code>：查看用户 UID、GID 信息  </li><li><code>su &lt;用户名&gt;</code>：切换用户身份  </li><li><code>sudo &lt;命令&gt;</code>：以管理员权限执行命令  </li><li><code>chmod &lt;权限&gt; &lt;文件&gt;</code>：修改文件权限  </li><li><code>chown &lt;用户:组&gt; &lt;文件&gt;</code>：修改文件所有者  </li><li><code>chgrp &lt;组&gt; &lt;文件&gt;</code>：修改文件所属组</li></ul><hr><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="1-查看进程"><a href="#1-查看进程" class="headerlink" title="1. 查看进程"></a>1. 查看进程</h3><ul><li><code>ps</code>：查看当前终端的进程  <ul><li>常用参数：  <ul><li><code>ps -ef</code>：查看系统中所有进程  </li><li><code>ps aux</code>：查看所有进程的详细信息</li></ul></li></ul></li><li><code>top</code>：动态显示进程状态  </li><li><code>htop</code>：更友好的交互式进程监控（需安装）  </li><li><code>pgrep &lt;关键字&gt;</code>：按名称搜索进程 ID</li></ul><h3 id="2-控制进程"><a href="#2-控制进程" class="headerlink" title="2. 控制进程"></a>2. 控制进程</h3><ul><li><code>kill &lt;PID&gt;</code>：结束指定进程  </li><li><code>kill -9 &lt;PID&gt;</code>：强制终止进程  </li><li><code>pkill &lt;进程名&gt;</code>：按名称终止进程  </li><li><code>jobs</code>：查看后台任务  </li><li><code>bg</code>：将任务放入后台  </li><li><code>fg</code>：将任务调回前台</li></ul><hr><h2 id="三、网络管理"><a href="#三、网络管理" class="headerlink" title="三、网络管理"></a>三、网络管理</h2><h3 id="1-网络信息查看"><a href="#1-网络信息查看" class="headerlink" title="1. 网络信息查看"></a>1. 网络信息查看</h3><ul><li><code>ifconfig</code>：查看或配置网络接口（旧命令）  </li><li><code>ip addr</code>：查看 IP 地址信息  </li><li><code>ip link</code>：查看网络接口状态  </li><li><code>ip route</code>：查看路由表  </li><li><code>ping &lt;主机&gt;</code>：测试网络连通性  </li><li><code>traceroute &lt;主机&gt;</code>：跟踪数据包路径  </li><li><code>netstat -tuln</code>：查看监听端口  </li><li><code>ss -tuln</code>：替代 <code>netstat</code> 的现代命令  </li><li><code>curl &lt;URL&gt;</code> &#x2F; <code>wget &lt;URL&gt;</code>：测试网络下载或接口请求</li></ul><h3 id="2-网络服务与连接"><a href="#2-网络服务与连接" class="headerlink" title="2. 网络服务与连接"></a>2. 网络服务与连接</h3><ul><li><code>scp &lt;源&gt; &lt;目标&gt;</code>：在主机间复制文件  </li><li><code>ssh &lt;用户&gt;@&lt;主机&gt;</code>：远程登录  </li><li><code>ftp &lt;主机&gt;</code>：FTP 连接  </li><li><code>nmap &lt;主机&gt;</code>：端口扫描（需安装）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt user@192.168.1.10:/home/user/    <span class="comment"># 上传文件到远程主机</span></span><br><span class="line">scp user@192.168.1.10:/home/user/file.txt .   <span class="comment"># 从远程主机下载文件到当前目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh alice@192.168.1.10          <span class="comment"># 以 alice 用户身份登录远程主机</span></span><br><span class="line">ssh -p 2222 root@server.example.com  <span class="comment"># 使用自定义端口 2222 登录远程服务器</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、文本格式化与处理"><a href="#四、文本格式化与处理" class="headerlink" title="四、文本格式化与处理"></a>四、文本格式化与处理</h2><h3 id="1-基本文本操作"><a href="#1-基本文本操作" class="headerlink" title="1. 基本文本操作"></a>1. 基本文本操作</h3><ul><li><code>cat &lt;文件&gt;</code>：查看文件内容  </li><li><code>tac &lt;文件&gt;</code>：倒序显示文件内容  </li><li><code>head -n &lt;行数&gt; &lt;文件&gt;</code>：显示文件前 N 行  </li><li><code>tail -n &lt;行数&gt; &lt;文件&gt;</code>：显示文件后 N 行  </li><li><code>less &lt;文件&gt;</code> &#x2F; <code>more &lt;文件&gt;</code>：分页查看文件</li></ul><h3 id="2-文本搜索与筛选"><a href="#2-文本搜索与筛选" class="headerlink" title="2. 文本搜索与筛选"></a>2. 文本搜索与筛选</h3><ul><li><code>grep &lt;模式&gt; &lt;文件&gt;</code>：搜索匹配的行  <ul><li>常用参数：  <ul><li><code>-i</code>：忽略大小写  </li><li><code>-v</code>：反向匹配  </li><li><code>-r</code>：递归搜索目录</li></ul></li></ul></li><li><code>awk &#39;&#123;print $1, $2&#125;&#39; &lt;文件&gt;</code>：字段提取与格式化输出  </li><li><code>sed &#39;s/旧/新/g&#39; &lt;文件&gt;</code>：流编辑器替换内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1, $3&#125;&#x27;</span> /etc/passwd     <span class="comment"># 输出每行的第1和第3个字段</span></span><br><span class="line">awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /etc/passwd     <span class="comment"># 指定分隔符为冒号，输出用户名</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/error/ERROR/g&#x27;</span> logfile.txt     <span class="comment"># 将所有 &quot;error&quot; 替换为 &quot;ERROR&quot;</span></span><br><span class="line">sed -i <span class="string">&#x27;s/localhost/127.0.0.1/g&#x27;</span> config.conf  <span class="comment"># 直接修改文件内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-排序与统计"><a href="#3-排序与统计" class="headerlink" title="3. 排序与统计"></a>3. 排序与统计</h3><ul><li><code>sort &lt;文件&gt;</code>：排序  </li><li><code>uniq &lt;文件&gt;</code>：去重  </li><li><code>wc &lt;文件&gt;</code>：统计行数、单词数、字符数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l *.<span class="built_in">log</span>            <span class="comment"># 统计当前目录下所有日志文件的行数</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、管道与重定向"><a href="#五、管道与重定向" class="headerlink" title="五、管道与重定向"></a>五、管道与重定向</h2><h3 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1. 标准输入输出"></a>1. 标准输入输出</h3><ul><li><code>&gt;</code>：重定向输出到文件（覆盖）  </li><li><code>&gt;&gt;</code>：重定向输出到文件（追加）  </li><li><code>&lt;</code>：从文件读取输入  </li><li><code>2&gt;</code>：重定向错误输出  </li><li><code>&amp;&gt;</code>：同时重定向标准输出和错误输出</li></ul><h3 id="2-管道操作"><a href="#2-管道操作" class="headerlink" title="2. 管道操作"></a>2. 管道操作</h3><ul><li><code>command1 | command2</code>：将前一命令输出作为后一命令输入  <ul><li>示例：  <ul><li><code>ps aux | grep nginx</code>：筛选 nginx 进程  </li><li><code>cat file | grep &quot;error&quot; | sort | uniq</code></li></ul></li></ul></li></ul><hr><h2 id="六、多参数与组合命令"><a href="#六、多参数与组合命令" class="headerlink" title="六、多参数与组合命令"></a>六、多参数与组合命令</h2><h3 id="1-多参数命令"><a href="#1-多参数命令" class="headerlink" title="1. 多参数命令"></a>1. 多参数命令</h3><ul><li><code>ls -alh</code>：显示详细信息并以人类可读格式输出  </li><li><code>tar -czvf archive.tar.gz dir/</code>：打包压缩  </li><li><code>find /path -type f -name &quot;*.log&quot;</code>：查找特定文件</li></ul><h3 id="2-逻辑运算与多命令执行"><a href="#2-逻辑运算与多命令执行" class="headerlink" title="2. 逻辑运算与多命令执行"></a>2. 逻辑运算与多命令执行</h3><ul><li><code>command1 &amp;&amp; command2</code>：前者成功后执行后者  </li><li><code>command1 || command2</code>：前者失败后执行后者  </li><li><code>command1; command2</code>：顺序执行两条命令  </li><li><code>()</code>：在子 Shell 中执行命令组  </li><li><code>&#123; command1; command2; &#125;</code>：在当前 Shell 中执行命令组</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux 系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/11/07/2024-11-7-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/11/07/2024-11-7-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="建立这个博客的初衷"><a href="#建立这个博客的初衷" class="headerlink" title="建立这个博客的初衷"></a>建立这个博客的初衷</h2><p>想要一点一点记录自己走过的路，无论是关于技术还是关于生活，留下一点痕迹</p><h2 id="目标规划"><a href="#目标规划" class="headerlink" title="目标规划"></a>目标规划</h2><p>建立两个大的板块：技术分享，生活碎碎念</p><p>技术分享：1. 关于计算机科学专业的一些通用技巧 2. 关于我研究方向的前沿知识</p><p>生活碎碎念：1. 描述某段经历 2. 归纳一些生活的规律 3. 记录一些突发的感想</p><p>TODO：</p><ul><li><input disabled="" type="checkbox"> 完善分类系统</li><li><input disabled="" type="checkbox"> 完成三篇正式生活博客的撰写</li><li><input disabled="" type="checkbox"> 完成三篇关于深度学习、Linux、电脑操作技巧的博客的撰写</li><li><input disabled="" type="checkbox"> 完善网站的 Meta 信息</li><li><input disabled="" type="checkbox"> 链接到博主的其他平台的账号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客初始化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
